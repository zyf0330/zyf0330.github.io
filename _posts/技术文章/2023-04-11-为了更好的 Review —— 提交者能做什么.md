---
layout: post
title: '为了更好的 Review —— 提交者能做什么.md'
date: 2023-04-11
category: 技术文章
---

# 开头

很多人都知道代码 Review 不是一件简单的事，在很多环节很多方面要注意很多事情。

同时，一些人对如何做好 review 也没有太多经验，尤其是新人，头几次 PR 有很多明显的问题。

因此这篇文章，在实践层面列举一下我的经验，关于  **提交 PR 的人**  在   **Git**   层面可以做哪些事，能使得   **Review**   达到更好的效果。

> 只涉及与 Git 相关的部分，不涉及其他方面，诸如代码质量、测试等等

# 一次 PR 的各个环节

这里我用我们最常用的开发流程来作为场景，介绍每个环节各个步骤如何做的更好



## 创建分支

开发的第一步

> 这个环节要做的事，其实跟代码 Review 没太大关系。算是借这个地儿顺带写一下。

|步骤|建议|目的|详细解释|
|:---:|:---:|---|:---:|
|选择创建分支的基分支|在改动要涉及到的分支中，选其他分支都包含的分支作为基分支,举例：比如要给 prod 环境做紧急修复，应该基于 prod 对应的分支做修复，然后把这个修复合并到 rc（如有） 和 develop 分支|为了将提交合并到其他分支时，能使用 merge 而非 cherry-pick|1. 为何不是基于 develop 开发？  
比如，如果现在是为 prod 做紧急修复，基于 develop 的开发不能保证代码改动完全适用于 prod 代码
1. 为何不用 cherry-pick？  
我们倾向于使用 merge。而正是因为提交在了 develop 上，此时才无法使用 merge。且使用 cherry-pick 也有可能将不适用的代码放到 prod 上去
1. 为什么提倡使用 merge？  
首先提倡的是在主分支（master, rc, develop, ...)之间进行 merge。举个例子：经常我们需要检查某个改动是否应用到了某个环境，使用 merge 确保所有分支上这个改动都对应同一个提交，利用   `git branch --contains commit`   轻易地检查，而使用 cherry-pick 无法做到。
1. cherry-pick 有自己的适用场景，而在我们的场景里基本都是滥用，这里不赘述。
|
|起分支名|分支名应该准确的反应出要进行的工作的  **类型**  和  **内容**,或使用关联任务Id也可|在本地并行开发多个工作时，让自己能清晰分辨对应的分支|类型：feat、fix、refactor 等等,内容：简略描述改动|




## 第一版代码

根据预期的需求，对代码做相应的改动完毕。

|步骤|建议|目的|详细解释|
|:---:|:---:|---|:---:|
|确认提交要包含的文件和改动内容|改动内容要符合分支名或任务内容的主题|1. 一次做一件事
1. 避免 reviewer 看到名不符实的 PR
|一次做一件事：,1. 方便不再需要改动时，可以直接回滚
1. 方便 reviewer 一次 review 一个改动等等
|
|写提交信息|- 标题：type(scope): title #ref
- 内容：如果改动较为复杂，写一些来描述改动的背景、设计思想等等概括性的东西
|1. 创建 PR 时会据此自动生成标题和内容，供 reviewer 了解 PR 相关信息
1. #ref 自动关联到任务，方便反向追溯
|1. PR 标题的重要性，可以参考作文、文章、论文标题的重要性
1. #ref 也是很重要的。一些陈年代码经常需要追溯业务需求层面的背景，来确认当初的意图以及决定现在的逻辑
|


## 后续提交

当第一版代码有一些小问题，需要微调时，你需要进行后续改动和提交

> 如果你的第一版代码和预期差得太远，包括但不限于改动内容不符合预期设计、有重大缺陷、质量太差，那么你接下来要做的的不是后续提交，而是关闭 PR 并根据反馈重构代码或重写。

> 如果你的第一版代码就被 approve，就更不需要后续提交了。

|步骤|建议|目的|详细解释|
|:---:|:---:|---|:---:|
|处理 Github Conversation|在处理完毕后再 resolve,- 通过对话讨论处理完毕
- 通过提交代码处理完毕
|1. 留存记录（主要是技术实现层面的），也可通过任务讨论
1. resolved 显示问题已经被解决
|对话的开始是因为对代码实现有分歧，结束是因为达成共识，此时对话才具备了 resolve 的条件,reviewer 若发现 resolved 却实际没有改动的情况，无疑会混淆视听|
|改动代码后提交|- 不要 amend 提交而是创建新提交
- 提交信息符合改动内容
|方便 reviewer 根据后续提交，只关注你每次变更的内容，而不是每次都看完整的改动|1. 准则就是，只进行 git push，而不要 force push
1. 如果改动很简单，比如一个变量名、一行不合适的测试，那 amend 提交也无所谓
|
|代码和主线相比已经过期|- 如不依赖主线代码，在准备合并时再合并主线更新
- 如果要依赖主线改动，尽量 merge 而非 rebase
|不产生不必要的提交|1. 不必要的提交会干扰对 PR 本身的 review
1. 如果 rebase 主线，不论是否需要解决冲突，都可能会影响本 PR 改动的代码，无法轻易的 diff review。  
而 merge 的话，会形成一个 merge 提交，方便只 review 这个提交
|


## approved 准备合并

> 这个环节其实也属于 review 之外，鉴于是 PR 的最后一步，就一起写在这里。

|步骤|建议|目的|详细解释|
|:---:|:---:|---|:---:|
|如何处理超过一个提交|1. 如果后续提交都是一些小调整，在 github 选择 squash and merge
1. 少数情况，这个 PR 的改动庞大，其中每个提交都是一个阶段性变动，选择 merge
|使得主线分支上的提交足够精简且保留必要的信息|1. 在 PR 内做后续提交时，避免 amend 合并提交是为了逐个 review，而现在 approved 后，那些微小调整对应的提交，在主线分支（如 develop）这个维度上是没有信息量的，所以压缩起来更简洁。
1. 而对于一次庞大的改动（如模块级别的初始化），其每个提交都应该是经过精心整理的，信息也足够重要，所以保留更好
|


# 结尾

本文都是个人的经验总结，如果有不对或不准确的地方，希望大家评论指出。

