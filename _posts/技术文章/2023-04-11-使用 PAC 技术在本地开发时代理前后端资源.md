---
layout: post
title: '使用 PAC 技术在本地开发时代理前后端资源.md'
date: 2023-04-11
category: 技术文章
---

 背景

在开发过程中，经常需要在本地进行前后端联调，场景一般是

1. 本地启动前端或后端某个项目，而另一端使用 live 环境的服务
1. 或是前后端均在本地启动
1. 前后端同学各自本地启动各端项目，进行跨电脑局域网联调


目前有几种方案覆盖这个场景，但是均有不足。因此我考虑使用一种新的方案，来统一这些场景。经过考察，我决定使用 PAC 技术来实现。

下面先列一下现有各个方案的特点，然后再介绍一下使用 PAC 技术的方案。

> 由于众口难调且有路径依赖问题，因此本文主要是秉着分享的目的，至于该方案是否值得推广则由市场决定😁。

# 现有方案

共同缺点：

1. 前后端各自有各自的方案，不统一
1. 都需要设置 Host 解析


再列举一下各方案的优缺点

## Nginx 等代理工具

后端常用

优点：

1. 强大，能实现所有功能，且没有下列其他方案这样那样的小问题
1. 作为标准 http 代理工具，协议兼容性最好


缺点：

1. 使用难度较大，尤其对于前端开发者对此工具不够熟悉难以掌握
1. 配置规则繁琐


## 国森开发的代理工具

优点：

1. GUI，点点点方便
1. 系统级代理，可以支持非浏览器平台


缺点：

1. 同样是系统级代理，导致无法同时使用其他代理工具（你懂的）
1. 有时失灵
1. 不够跨平台且客户端重
1. 代理服务期地址是 ip 会破坏正常功能，需要手动设置 Host
1. 由于技术实现带来的其他一些小问题


## 凯哥开发的 Portal 内置 /dev/forward

优点：

1. 内置，使用方便


缺点：

1. 未登录无法使用（由于前端路由体系基于 Portal）
1. 不支持个别项目如 Portal
1. 使用非 live 默认端口，导致 typhon 设置的登录 cookie 写入的 hostname 不符，破坏正常功能
1. 使用非 live 默认端口，使得浏览器记住的帐号无法使用
1. 如果代理服务器地址是 ip 而非域名，破坏正常功能，需要手动设置 Host


# PAC 方案

## 什么是 PAC

PAC 的全称是 Proxy Auto-Configuration，代理自动设置。跨平台兼容性很好，各个主流操作系统和浏览器等平台都支持。

它是一个  **正向**  代理，应用于客户端层，专用于   **http**   协议的请求（包括 ws）。

它工作的方式，简单说，就是根据请求的 url 来决定请求发送往的目标，而并  **不改写**  请求内容本身。

而它的特点呢，就是使用简单方便，Auto 一词足可表示，基于 PAC 提供的代理，一般只需要提供一个 http url 即可使用。

> 注意，由于近年来业界对于隐私的愈加重视，PAC 对于 https 等安全协议的支持受到了很多限制

> 关于 PAC 的技术介绍，参见   [MDN 关于 PAC 的文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/Proxy_servers_and_tunneling/Proxy_Auto-Configuration_PAC_file)  

## 为什么选择 PAC

PAC 的一些特点使得我决定采用它

- 专用于代理 http 请求，功能专一性
- 被主流浏览器和操作系统支持，  **跨平台**  兼容性好，无需做复杂开发
- 脚本配置  **简单**  （我们都写 JS）
- **保留 http 请求原本的内容**  （保留 Host 用来识别 team domain，以及写 cookie，etc...）
- 不需要调整 Hosts 解析
- **不影响原有代理工具**
- **最终达成前后端一致的、各子产品一致的、本地连通 live 环境的开发体验！**


> 说实话，我们当前的本地开发配置已经连通了 live 环境，可以说是天然打通了 live 和本地开发的障碍，但是前端代理却还在使用 local 系域名用于本地开发。我做这件事情的出发点就是想消除这个不和谐。

## ！！！用于连接本地和 live 环境的 PAC 脚本！！！

**这里是本文的重头戏。**

先贴上 PAC 脚本。这是我针对当前开发场景写的脚本，使用起来已经比较方便（依旧没有 GUI 点点点，然后我更喜欢用效率更高的 vim），且支持目前我已知的大多数开发场景使用方式。

[pingcode.live.pac](pingcode.live.pac.js)

> 注意：在各平台的隐私限制下，只有 https url 中的 hostname 能被 pac 脚本获取到，而我们的场景却需要使用 pathname 来进行路由，因此如果用 https 协议是无法正常使用的。

### 简单介绍脚本使用方式

里面第一段是自定义配置节，是平台会需要手动配置的

-   `enabledDomains`  配置代理哪些团队域名，  `.`  是 pingcode.dev，  `*`  是所有域名，注释即禁用
-   `enabledProxyEnds`  配置是否对前端和后端启用，注释即禁用
-   `enabledProxyApps`  配置代理哪些子产品项目，优先级低于  `enabledProxyEnds`  ，注释即禁用
-   `fallbackProxy`  配置不被代理的请求去往哪里，默认是原路访问，可以指向自己使用的代理


脚本内容都是 JS 且逻辑极为简单，大家可以直接阅读代码来了解工作方式，并且进行自定义。

关于脚本的原理，后端部分十分简单就不多言了，而前端部分需要了解前端资源路由体系，感兴趣的同学可以请教前端同学了解。

### 补充

1. 此脚本对于后端服务来说，已经可以直接使用了
1. 而对于前端服务，要想正常使用，各个项目需要设置   `deployUrl=/static/${application}`  ，将各自服务的资源路由区分开。不过如果同时只需要开发一个项目，也可以改写脚本的路由判断条件。
1. 而对于 Portal 来说，由于前端资源加载体系是基于它的，因此还需要一些额外的配置才能正常工作。具体可以查看   `walker/static-portal`  分支。


## 如何应用 PAC 脚本

常用的使用平台分为浏览器和操作系统，代理各自范围内的 http 请求

下面介绍一下各个平台使用 PAC 的方式。其中有的方式支持直接填写 PAC 脚本的内容，有的支持通过文件协议访问，但它们都支持通过 http url 访问

### 浏览器扩展 （推荐）

> 推荐扩展   [SwitchyOmega](https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif)  

优点：

1. 只会应用于浏览器，不影响系统其他应用
1. 方便更新（系统级别的配置一般在切换网络时才能刷新）
1. 没有跨平台兼容性问题

![SwitchyOmega](SwitchyOmega.png)

### Ubuntu KDE 系统代理配置

> 其他 Linux 发行版类似

优点：如果有需要在非浏览器中代理，比如飞书应用，只能采用这种方式。

![UbuntuPlasmaPAC](UbuntuPlasmaPAC.png)

### MacOS 系统代理配置

![MacOSPAC](MacOSPAC.png)

### Windows 系统代理配置

![WindowsPAC](WindowsPAC.png)

### Android 系统代理

位于 Wifi 设置中

![AndroidPAC](AndroidPAC.jpeg)

# 

## 描述使用体验

这里叙述一下我的使用过程

1. 使用 SwitchyOmega 扩展，（PAC 代理条目常驻无需切换）
1. 如果需要更新规则：
    1. 打开习惯的文本编辑器，启用或禁用要代理的项目，保存
    2. 点击扩展弹出菜单的对应条目即可触发更新（无需进入扩展选项菜单去点击更新）
    3. 生效

# 尾

希望大家看完后能对 PAC 有更深的了解。另外，提高工作效率是非常重要的，这要求我们不断的去了解新东西（事实上我相信很多人知道和了解 PAC ，都是始于开始使用某种不可言说的工具🤔）。

