---
layout: post
title: '排查一次依赖问题导致的错误.md'
date: 2023-04-11
category: 技术文章
---

# 前言

最近都在 ladon 和 pc-core 项目里奋斗，许久没有打开 typhon。今天需要在 typhon 里写一些代码，在跑测试的时候，发现 Jest 在入口全局脚本里报了一个错，一个非常意外的错误。

说它意外，是由于

- **错误出现的位置在这之前从来没有出现过**
- **它的错误信息也很陌生**
- **最近项目没有改动过**


在解决之后，这个问题本身的独特性，促使我将它记录下来。



# 排查

这个错误是 Jest 在执行入口文件   `globalSetup.ts`   时报的错，瞟了一眼  **错误栈**  后，发现没有跟项目源文件相关的行。

再执行一次，还是相同的错误。错误出现的时间距离启动开始  **很短**  ，再加上错误栈中没有出现源文件，所以猜测是依赖导入阶段报的错。

这个文件开头的   `import`   语句只有四行，因此我直接在第一行打断点，一行一行走，发现的确是其中某一行里报的错。

现在，确认了错误是发生在导入依赖过程中，我重新仔细看了一遍错误栈，确认了导入链条。导入链条和栈本身很浅，只有三五层。

在报错处下断点重新运行，在断住后我打算  **逐级查看上一层栈**  。在往上跳了一级后，就发现是 koa 底层依赖的一个   `http-errors`  包里在调用   `statuses`  包，查看报错处的相关变量，很容易就了看出来，这里调用方式错了。

what？！这不可能吧，koa 下面依赖的包会有这么明显的错误？！我确认了一下相关包的版本，已经发布很久了，因此排除了这个怀疑。

我决定多做一些测试来确认，先把这处代码改成正确的，然后我重新运行，发现另一个地方也报错了，是同样的形式，只是这次调用   `statuses`   的地方是另一个包。两个地方同样的调用错误，这同样是不可接受的。

但谨慎起见，我先去其中一个包的 github 源代码仓库翻看对应位置的实际代码，发现是正确的调用方式，然而我又注意到，PR 的标题是升级   `statuses`   依赖。然后我重新检查了本地实际安装的包和它的   `statuses`  依赖版本，发现版本没有问题，然而这里  **实际调用**  的却是另一个版本的   `statuses`  。`

到这里，问题已经进入了一个新的阶段，也比较明朗了，需要确认  **为什么执行时调用了错误的包**  。

如果对   [node 的寻找 node_modules 依赖过程](https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_loading_from_node_modules_folders)  有一些了解，就应该知道，当导入时会从当前目录开始一级一级往上找 node_modules，如果里面有对应的包就导入。检查实际安装的包，也的确是这样。

那么，难道是 yarn 安装依赖出了问题？使用   `yarn why statuses`  列出相关依赖树，发现对应的版本是正确的，这个版本是 lock 里记录的，另外，最近项目也没有发生过改动。所以，是安装过程出了问题？

> 这里要注意 yarn 的一个“陷阱”，那就是执行   `yarn install`  时，yarn 不会像 npm 一样实际去检查每个对应的包是否存在，而是利用 lock 和 node_modules 内的   `node_modules/.yarn-state.yml`  （所以它才能那么快）

实际执行   `yarn install`  还是报错，所以我把整个 node_modules 删掉重新安装，现在问题消失了。

# 回顾

整个排查过程，前半部分平平无奇，而后半部分还是比较独特的，由于之前没有碰上过这类问题。

那么，问题是怎么出现的呢？由于 koa 是 chaos 提供的依赖，我想是因为我之前在测试 chaos 代码时，直接将 chaos build 好的文件复制替换了 typhon node_modules 的 chaos 包，然后单独在里面执行了   `npm install`  安装依赖，这导致 yarn 无法正确的跟踪依赖版本。后来我没有  **及时做清理**  ，隔了一段时间给忘了。



至此，这次事件就真相大白了。

