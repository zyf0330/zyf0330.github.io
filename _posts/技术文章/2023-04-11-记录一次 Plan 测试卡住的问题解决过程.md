---
layout: post
title: '记录一次 Plan 测试卡住的问题解决过程.md'
date: 2023-04-11
category: 技术文章
---

# 前言
在几个月前我对 Plan gaea 项目进行一次功能开发后，出现了一个问题，测试会卡在一个固定的地方。而这个地方，就位于这次功能开发所写的测试中。
这个问题被尝试解决过多次，但一直无果，今天终于找到了原因，并且原因涉及到基础库，实在是心情激动！

# 解决过程
## 问题描述
这个功能是提供一个 RPC 来获取指定多个团队的项目集数据，出于严谨起见，测试用例中对多个团队的数据进行了操作，这就涉及到使用 `PassportSimulator` 多次登出不同的团队，而这个调用内部要操作 Redis。
问题的直接表现是，当执行到第一个 `PassportSimulator` 调用时，阻塞了。项目是使用 Mocha 串行跑的，且每次运行测试时各用例的执行顺序不变。当这个问题出现时，测试程序总是卡在那句代码的位置。
## 第一阶段
首先定位问题的出现原因。在指定跳过这个测试后，问题消失了。这样确定问题的确是这个测试导致的。另外，这个测试单独跑也能过。
我首先怀疑的地方，是测试逻辑上有问题。不像别的测试用例，这个测试在一个用例内多次调用了登录登出。但和同事一起重新 review 后并没有发现什么不合适的逻辑。
那么我只好调试代码，试图从技术层面找到原因。在注释这几个调用后，测试不再阻塞。然后我从阻塞的代码开始，一句句进入，最终定位到是一句 cache 的 `smembers` 调用阻塞住了没有返回。
这种情况我并没有见过。到这儿已经是 ioredis 和 Redis 的领域，以我过去的经验，如果是调用出错，比如由于函数调用有误、连接问题，都是会出现不同的异常的，但从来没阻塞住过。我继续深入调试，到了 ioredis 将命令网络包发出去的逻辑处，还是没有发现问题。连接状态正常，逻辑正常。
我又尝试抓包，发现 `smembers` 命令被成功的发出往 Redis 服务端，并且多观察一会儿，能看到两端之间的心跳包，说明连接的确是正常的。那么 Redis 为什么没有响应呢？我使用 cli 在宿主机上使用和测试程序同样的 docker 网段地址，单独去连接 Redis 并执行同样的命令，成功返回。同时我在抓包中也能观察到一模一样的命令被发出去，不同的是这次有了响应。
难道是 Redis 有 bug？我使用了不同版本的 Redis 重试，并司马当活马医地更改了 ioredis 的版本，但问题依旧。

此时我的心情是崩溃的。。。已经处理很久了却没有端倪。我决定先搁着，休息一下。

到这儿，问题的现象是，`smembers`命令在连接上没有收到 Redis 的响应。

## 第二阶段
> 这期间还试图解决过，但也没什么思路和进展。继续搁置。直到今天我得空，决定重新尝试解决一下这个问题。

我先重装了一遍 `node_modules`、docker 镜像什么的，试图碰碰运气，然而无果。
我突然想到测试顺序的执行是固定的，就把这个测试改了名让它换到第一位去跑，这次跑过了。我重新仔细观察了一下它执行的位置，发现是倒数第二个，测试程序快要结束。我怀疑是否有什么漏洞，导致 Redis 客户端提前被销毁且处于中间状态。但检查代码，发现也没有 ioredis 的 `quit` 或 `disconnect` 等命令的调用。再说了，即使有调用，也会在连接状态上体现出来。但连接在阻塞后很久都维持正常。
没有线索，我重新检查了一下抓包内容。发现里面有两个 Redis 服务器的地址，但其中一个地址的通信只会在测试开始时有几个长度为0的包（TCP），而且不是测试启动的 docker Redis 的地址段，太奇怪了！但测试代码中并没有启动过相关的 Redis 客户端。看出现的时机也不是很相关，就先忽略它。
在这个步骤，我检查了所有包相关地址，除了上面检查了 Redis 服务的地址，我还被启发去检查了所有 Redis 客户端的地址端口，发现在测试中有多个连接被建立和通信。对此我不意外，因为我知道很多地方是使用 `cache.duplicate()`来复制一个新的实例去进行调用，比如——`brpop`！
我突然就这么联想到，前不久 Typhon 改造异步队列用了 `brpop`，它的作用是监听一个列表，效果是**阻塞连接**。会是 Redis blocking 调用导致的吗？！
我在抓包中寻找相关的调用，果然找到了 `brpop`，并且确认它使用的本地端口和 `smembers`调用使用的连接一致。由于我不知道 blocking 调用在连接层面的表现是什么，所以还不能确定这就是原因。
我定位到 `brpop` 的调用发生在 eros 的 app initializer 中，的确有一个测试用例启动了它。本来传入给它的 cache 实例是程序主实例，我改成 duplicate 出来的实例重新运行测试。

看着测试用例一个个跑过，我越发激动，在越过阻塞的用例后，我松了一口气。问题消失了。

## 问题被解决
终于，问题原因找到了！一个测试使用了 Plan 的 app initializer，而它将程序主 cache 实例传入并在内部被调用 blocking 命令，导致后续使用主 cache 的调用都被阻塞住没有响应。

那么这个问题怎么解决呢？
正确的做法——显然不是在 Plan 这儿 duplicate 一个 cache 实例。因为 app initializer 模块并没有任何措施让使用者知道或避免进行这样的误用，这是个设计问题。
那么，让 app initializer 内部去 duplicate 好吗？也不是很好，因为部署层面 initializer 是个单独的服务，多一个连接多浪费呀。
那么可能比较合适的一种做法是，app initializer 不要求传入 cache 实例而是地址，由自己来实例化 cache，这样 initializer 要如何使用 cache 也不影响外界。
但鉴于目前的设计已经难以被改变，还是直接在内部 duplicate 一个实例出来最简单直接。

# 后语
之所以这个问题能在我心上挂了好几个月，是因为我从来没遇到过类似的现象。我觉得这一定是我的视野盲区。

我的收获有两点：
1. 在实践层面知道了 Redis blocking 命令阻塞连接的表现。
2. 设计和实现模块，需要谨慎的考虑其行为。容易被误用的代码是很危险的。

