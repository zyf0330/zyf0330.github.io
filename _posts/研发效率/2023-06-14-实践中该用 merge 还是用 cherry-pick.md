---
layout: post
title: '实践中该用 merge 还是用 cherry-pick.md'
date: 2023-06-14
category: 研发效率
---

有的人喜欢用 merge 有的人喜欢用 cherry-pick ，但两个东西既然不一样，那总是有功能上和适用场景的区别。这里我们聊聊这一点。

cherry-pick 实质上就相当于做了一次  **新提交**  ，这过程即是，被 cherry-pick 的提交中包含哪些  **改动内容**  ，你将它们在目标分支上做相同的改动然后做提交。想象一下你在手动改代码时，是否要考虑代码是否能正常工作，那么当 cherry-pick 发生时，git 只是自动将改动内容应用到目标分支上，而是否能正常工作也需要由你来决定，同时目标分支和源分支很可能是不同的代码，这也就是 cherry-pick 为什么经常产生冲突。
另外，也正由于 cherry-pick 是基于改动内容合并的，这导致它会破坏分支的正常合并流程。正常的顺利的 merge ，所谓的 fast-forward，是由于 git 会检测分支上的  **提交的父子依赖关系**  ，确定冲突是否会发生。而现在由于 cherry-pick 产生了新的提交，merge 过程在经过这样的提交时，必须改为检测提交的改动内容来决定是否有冲突，当这一检测发生时，merge 就已经不再是 fast-foward 的了。此时大部分情况你需要  **手动**  处理，即使你发现 VSCode 或 Idea 提示你可以直接合并改动而无实质的冲突发生。

merge 就稍微简单一些了，上面也略微提到。merge 处理的对象是  **分支**  ，而不是某个提交的改动内容。merge 的冲突检测，发生在两个分支的 HEAD 对应的代码上。大多数情况，Git 通过 HEAD 提交的先后顺序和内容检测，会自动进行处理，否则需要手动处理，由于只发生在一个提交交汇处，那么冲突最多只有一次。冲突的解决、交汇点的形成，就是 merge commit。从这里开始，你无需再考虑从前的分支和代码，它们已经在此刻合为一体，以后会往一个方向前进，除非重新 fork.

portal 的项目，甚至是大多数子产品的项目，主要是 develop 和 master 分支，对应开发环境和线上环境，并且这俩分支互为基础，develop 基于 master 做开发，master 基于 develop 做发布。而 develop 和 master 的差异，是一个迭代的开发内容，要经过迭代开发完毕到上线之间的两周测试。之所以有这样的分支结构，是由于我们的产品代码总是往一个方向生长。至于 feat 分支，只是短暂存在，开发完毕后就会汇入 develop 分支。
对于这种代码演进流程，cherry-pick 这个操作是完全不适用的。cherry-pick 的适用场景是，从一个分支中摘取某几个提交的改动内容到另一个分支上，而不必以分支级别包含改动。这用于在你只想要将某些提交而非整个分支的改动包含到另一个分支内的情况。
这种场景一般见于，需要维护多发布版本的项目，比如像 Node，Node 需要同时维护 UNSTABLE、MAINTENANCE、ACTIVE、CURRENT 四个阶段，到现在为止超过20个版本的发布，代码库包含至少50个分支。你在主线上或是其他分支上进行了一次 fix，你不可能把这个分支合并到旧的 release 上，因为每个 release 不能包含其他 release 。你也不能简单的在最旧的分支上进行 fix 然后把它合并到所有较新的 release 上，因为不同的 release 上同一功能的代码可能已经发生了变化，所以同样的 fix 代码可能产生差异。这时最好用 cherry-pick ，只专注于某个 fix 的改动不必考虑分支上的其他改动的影响。但缺点就是你无法很好的跟踪分支是否包含某个修复，所以必须引入脱离于 Git 之外，且作用于 Git 的缺陷发布追踪系统。
> 这里附上 Node 的  [代码库](https://github.com/nodejs/node)  和  [发布页面](https://nodejs.dev/en/about/releases/)  

cherry-pick 含义是摘樱桃，想象一下在枝干（branch）上摘樱桃（commit），这个动作或许能帮助你理解它。
拿河流的分支与交汇来想象 branch 的 fork 和 merge 吧，二者是很相似的。

再说回习惯的问题，对于我们的项目来说，用哪种也没有太多区别，因为体量不够大、问题不够明显。

